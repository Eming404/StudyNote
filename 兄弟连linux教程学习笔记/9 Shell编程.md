# 第一章 正则表达式

## 1.1 正则表达式与通配符

- 正则表达式用来在文件中匹配符合条件的字符串，正则是包含匹配。grep、awk、sed等命令可以支持正则表达式。
- 通配符用来匹配符合条件的文件名，通配符是完全匹配。ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符进行匹配。

## 1.2 基础正则表达式

|  元字符   | 作用                                                         |
| :-------: | ------------------------------------------------------------ |
|     *     | 前一个字符匹配0次或任意多次。                                |
|     .     | 匹配除了换行符外任意一个字符。                               |
|     ^     | 匹配行首。例如：^hello会匹配以hello开头的行。                |
|     $     | 匹配行尾。例如：hello$会匹配以hello结尾的行                  |
|    []     | 匹配括号中指定的任意一个字符，只匹配一个字符。如[aeiou]匹配任意一个元音字母，[0-9]匹配任意一位数字，\[a-zA-Z\]\[0-9\]匹配任意字母和一位数字构成的两位字符。 |
|    [^]    | 匹配除括号中的字符以外的任意一个字符。                       |
|     \     | 转义字符                                                     |
|  \\{n\\}  | 表示其前面的字符恰好出现n次。例如[0-9]\\{4\\}匹配4位数字，\[1]\[3-8]\[0-9]\\{9\\}匹配手机号码。 |
| \\{n,\\}  | 表示其前面的字符出现不小于n次。例如\[0-9]\\{2,\\}表示两位以上的数字 |
| \\{n,m\\} | 表示其前面的字符至少出现n次，最多出现m次。例如\[a-z]\\{6,8\\}匹配6至8位的小写字母。 |

# 第二章 字符截取命令

## 2.1 cut字段提取命令

- `cut [选项] 文件名` 
  - -f：列号，提取第几列
  - -d：分隔符，按照指定分隔符分割列，默认为制表符
- 举例
  - `cut -d ":" -f 1,3 /etc/passwd`	以“:”为分隔符，取第1和第3列。
- 限制
  - 分隔符不能是空格。

## 2.2 awk命令

 ### 2.2.1 printf命令

- `printf '输出类型输出格式' 输出内容`
  - 输出类型
    - %ns：输出字符串，n是数字指代输出几个字符
    - %ni：输出整数。n是数字指代输出几个数字
    - %m.nf：位数和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。
  - 输出格式
    - \a：发出警告声音
    - \b：输出退格键，即Backspace键
    - \f：清除屏幕
    - \n：换行
    - \r：回车
    - \t：水平制表符
    - \v：垂直制表符
- 举例
  - `printf '%s %s\n %s' 1 2 3 `
  - 无法接收管道符传递的命令运行结果
    - `cat student.txt | printf '%s'` 无法正确运行
    - `print '%s' $(cat student.txt)` 可以正确执行

- print和pringf
  - print：会在每个输出之后自动加入一个换行符。但Linux中没有print命令，只能在awk中使用。
  - printf：标准格式输出命令，手动加入换行符。

### 2.2.2 awk命令

- `awk '条件1{动作1} 条件2{动作2} ...' 文件名`
  - 条件(pattern)：一般使用关系表达式作为条件，例如大于等于>=。可缺省，表示无条件
  - 动作(Action)：格式化输出，流程控制语句 
- 举例
  - ``df -h | awk '{printf $1 "\t" $5 "\t" $6 "\n"}'`` ：$1表示第一列。语句执行过程位逐行读取，筛选需要显示的内容，直到遍历完所有内容。
  - ``df -h | grep sda5 | awk '{print $5}' | cut -d "%" -f 1`` ：读取根分区占用率

- BGEIN、END和FS
  - `awk 'BEGIN{FS=":"}{print $1 "\t" $3}' /etc/passwd` ：BEGIN条件表示在读取第一行内容之前执行其后括号内容，FS指定分隔符。如果不使用BEGIN，则先读取第一行内容，然后才执行按指定分隔符分割的动作。

- 关系运算符
  - `cat sutdent | grep -v Name | awk '$6>=87' {print %2 "\n"}` ：grep用于排除表头。

## 2.3 sed命令

​		sed是一种几乎包括在所有UNIX平台的轻量级流编辑器（支持管道符），主要用于将数据进行选取、替换、删除、新增。

- `sed [选项] '[动作]' 文件名` 
  - 选项
    - -n：一般sed命令会把所有数据都输出到屏幕，如果加入此选项，则只会把经过sed命令处理的行输出到屏幕。
    - -e：允许对输入数据应用多条sed命令编辑。
    - -i：用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出。
  
  - 动作
    - a\    追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用反斜杠代表数据未完结。
    - c\    行替换，用c后面的字符串替换原数据行。
    - i\     插入，在当前行前面插入一行或多行。
    - d     删除，删除指定的行
    - p     打印，输出指定的行
    - s     字符串替换，格式为`行范围s/旧字串/新字串/g` （和vim中的替换格式类似）

- 举例
  - `sed -n '2p' student.txt` 输出第二行
  - `sed '2,4d' student.txt` 显示删除第2至4行后的内容，不影响原文件。
  - `sed '2i Hello \ World' student.txt` 插入内容
  - `sed '2c Hello World' stedent.txt` 替换指定行
  - `sed '3s/74/99/g' student.txt` 把第三行的74替换为99
  - `sed -e 's/Liming//g;s/Gao//g' student.txt` s不加数字表示整篇文档，-e允许多个条件同时执行，用分号分割。

# 第三章 字符处理命令

## 3.1 排序命令sort

- `sort [选项] 文件名` 
  - -f：忽略大小写
  - -n：以数值型进行排列，默认使用字符串类型排序
  - -r：反向排序
  - -t：指定分隔符，默认分隔符为制表符
  - -k n[,m]：按照指定的字段范围排序，从第n字段开始，m字段结束（默认到行尾）。

- 举例
  - `sort -n -t ":" -k 3,3 /etc/passwd` 按数值，以:为分隔符，用第三字段开头、第三字段结尾排序，即只用第三字段排序

## 3.2 统计命令wc

- `wc [选项] 文件名` 
  - -l：只统计行数
  - -w：只统计的单词书
  - -m：只统计字符数

# 第四章 条件判断

## 4.1 按照文件类型进行判断

| 测试选项 |                  作用                  |
| :------: | :------------------------------------: |
|    -d    | 判断该文件是否存在，并且是否为目录文件 |
|    -e    |           判断该文件是否存在           |
|    -f    | 判断该文件是否存在，并且是否为普通文件 |

- `test -e /root/install.log` 然后使用`echo $?` 查看。问号表示上一条命令执行结果
- `[ -e /root/install.log ]` 左右括号必须和内容有空格分隔
- `[ -d /root ] && echo yes || echo no`

## 4.2 按照文件权限进行判断

| 测试选项 |                   作用                   |
| :------: | :--------------------------------------: |
|    -r    |  判断该文件是否存在，并且是否拥有读权限  |
|    -w    |  判断该文件是否存在，并且是否拥有写权限  |
|    -x    | 判断该文件是否存在，并且是否拥有执行权限 |

- 不区分所有者所属组

## 4.3 两个文件之间进行比较

|    测试选项     |                        作用                         |
| :-------------: | :-------------------------------------------------: |
| 文件1 -nt 文件2 |         判断文件1的修改时间是否比文件2的新          |
| 文件1 -ot 文件2 |         判断文件1的修改时间是否比文件2的旧          |
| 文件1 -ef 文件2 | 判断文件1是否和文件2的inode号一致，可用于判断硬链接 |

## 4.4 两个整数之间比较

|    测试选项     | 作用 |
| :-------------: | :--: |
| 整数1 -eq 整数2 |  ==  |
| 整数1 -ne 整数2 |  !=  |
| 整数1 -gt 整数2 |  >   |
| 整数1 -lt 整数2 |  <   |
| 整数1 -ge 整数2 |  >=  |
| 整数1 -le 整数2 |  <=  |

## 4.5 字符串的判断

|     测试选项     |         作用         |
| :--------------: | :------------------: |
|    -z 字符串     |  判断字符串是否为空  |
|    -n 字符串     | 判断字符串是否为非空 |
| 字符串1==字符串2 | 判断两字符串是否相等 |
| 字符串1!=字符串2 | 判断两字符串是否不等 |

## 4.6 多重判断

|    测试选项    |      作用      |
| :------------: | :------------: |
| 判断1 -a 判断2 |     逻辑与     |
| 判断1 -o 判断2 |     逻辑或     |
|    ！ 判断1    | 取反，需加空格 |

# 第五章 流程控制

## 5.1 if语句

### 5.1.1 单分支if条件语句

```shell
if [ 条件判断式 ]; then
	程序
fi
```

或者

```shell
if [ 条件判断式式 ] 
	then 	
		程序
fi
```

- 例

```shell
#!/bin/bash
# 统计根分区使用率
# Author:HuangYuan

rate=$(df -h | grep "/dev/sda3" | awk '{print $5}' | cut -d "%" - f1)
# 把根分区使用率作为变量赋予rate

if [ $rate -ge 80]
	then
		echo "Warning! /dev/sda3 is full!"
fi
```

### 5.1.2 双分支if条件语句

```shell
if [ 条件判断式 ]	 
	then
		条件成立时，执行的语句
	else 
		条件不成立时，执行的语句
fi
```

 ### 5.1.3 多分支if条件语句

```shell
if [ 条件判断式1 ]
	then
		条件判断式1成立时，执行的语句
elif [ 条件判断式2 ]
	then
		条件判断式2成立时，执行的语句
else
	所有条件都不成立时执行的语句
fi
```

- 例

```shell
#!/bin/bash
# 判断用户输入的是申明文件

read -p "Please input a filename:" file
# 接收键盘输入，并赋予变量file
if [ -z "$file" ] 	# 判断file变量是否为空
	then
		echo "Error,please input a file name."		
		exit 1			# 相当于break，否则会继续执行下一个elseif。可通过echo $?查看
elif [ ! -e "$file" ]	# 判断file的值是否存在
	then 
		echo "Your input is not a file!"
		exit 2
elif [ -f "$file" ]		# 判断file的值是否为普通文件
	then 
		echo "$file is a regular file!"
elif [ -d "$file" ]		# 判断file的值是否为目录文件
	then
		echo "$file is a directory!"
else 
		echo "$file is an other file!"
fi
```

## 5.2 case语句

```shell
case $变量名 in
	"值1")
		语句1
		;;
	"值2")
		语句2
		;;
	···省略其它分支···
	*)
		如果变量的值都不是以上的值，则执行此语句
		;;
esac
```

## 5.3 for语句

- 语法一

  ```shell
  for 变量 in 值1 值2 值3···	# 通过空格判断不同值
  	do 
  		程序
  	done
  ```

  - 例

    ```shell
    #!/bin/bash
    # 批量解压缩脚本
    
    cd /lamp
    ls *.tar.gz > ls.log
    for i in $(cat ls.log)
    	do 
    		tar -zxf $i &> /dev/null
    	done
    rm -tf /lamp/ls.log
    ```

- 语法2

  ```shell
  for (( 初始值；循环控制条件；变量变化))
  	do
  		语句
  	done
  ```

  - 例

    ```shell
    #!/bin/bash
    # 批量添加指定用户
    
    read -p "Please input user name:" -t 30 name
    read -p "Please input the number of users:" -t 30 num
    read -p "Please input the password of users:" -t 30 pass 
    
    if [ ! -z "$name" -a ! -z "$num" -a ! -z "$pass" ]
    	then
    		y=$(echo $num | sed 's/[0-9]//g')		# 将用户名中的数字替换为空
    			if[ -z "$y" ]
    				then 
    					for (( i=1;i<=$num;i=i+1))
    						do 
    							/usr/sbin/useradd $name$i &> /dev/null
    							echo $pass | /usr/bin/passwd --stdin $name$i &> /dev/null
    						done
    			fi
    fi
    ```

## 5.4 while循环

- 语法

  ```shell
  while [ 条件判断式 ]
  	do 
  		语句
  	done
  ```

  - 例

    ```shell
    #!/bin/bash
    
    i=1
    s=0
    while [ $i -le 100 ]	# i小于等于100
    	do 
    		s=$(( $s+$i ))
    		i=$(( $i+1  ))
    		done
    echo $s
    ```

## 5.5 until循环

​		格式同while，只是当循环条件满足时跳出循环，和while相反。